<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Search Demo</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f5f5f5;
      color: #333;
    }

    .container {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 100vh;
    }

    /* Left Panel - Filters */
    .filters-panel {
      background: white;
      border-right: 1px solid #e0e0e0;
      padding: 16px;
      overflow-y: auto;
      height: 100vh;
      position: sticky;
      top: 0;
    }

    .search-box {
      width: 100%;
      padding: 10px 12px;
      font-size: 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
      outline: none;
      margin-bottom: 20px;
    }
    .search-box:focus { border-color: #007aff; }

    .category {
      margin-bottom: 20px;
    }

    .category-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }

    .category-options {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .filter-option {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      font-size: 13px;
      background: #f0f0f0;
      border: 1px solid #e0e0e0;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.15s;
      user-select: none;
    }
    .filter-option:hover {
      background: #e8e8e8;
    }
    .filter-option.selected {
      background: #007aff;
      border-color: #007aff;
      color: white;
    }
    .filter-option.modifier-not {
      background: #ff3b30;
      border-color: #ff3b30;
      color: white;
    }
    .filter-option.modifier-must {
      background: #34c759;
      border-color: #34c759;
      color: white;
    }
    .filter-option .modifier-prefix {
      font-weight: bold;
      margin-right: 2px;
    }
    .filter-option .count {
      margin-left: 4px;
      opacity: 0.7;
      font-size: 11px;
    }

    .clear-filters {
      font-size: 12px;
      color: #007aff;
      cursor: pointer;
      margin-bottom: 16px;
      display: none;
    }
    .clear-filters:hover { text-decoration: underline; }
    .clear-filters.visible { display: block; }

    /* Right Panel - Results */
    .results-panel {
      padding: 16px 24px;
      overflow-y: auto;
    }

    .results-header {
      font-size: 13px;
      color: #666;
      margin-bottom: 16px;
    }

    .result {
      background: white;
      padding: 14px 16px;
      border-radius: 8px;
      margin-bottom: 10px;
      border: 1px solid #e8e8e8;
    }

    .result-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .result-name {
      font-weight: 600;
      font-size: 15px;
    }

    .result-type {
      font-size: 10px;
      background: #e0e0e0;
      padding: 2px 8px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .result-description {
      color: #666;
      font-size: 13px;
      line-height: 1.4;
    }

    .result-meta {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .result-tag {
      font-size: 11px;
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
      color: #666;
    }

    .empty-state {
      text-align: center;
      color: #999;
      padding: 60px 20px;
    }

    .loading {
      text-align: center;
      color: #999;
      padding: 60px 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="filters-panel">
      <input type="text" class="search-box" id="search" placeholder="Search..." autofocus>
      <div class="clear-filters" id="clearFilters">Clear all filters</div>
      <div id="filters"></div>
    </div>
    <div class="results-panel">
      <div class="results-header" id="resultsHeader"></div>
      <div id="results"><div class="loading">Loading...</div></div>
    </div>
  </div>

  <script type="module">
    import MiniSearch from 'https://esm.sh/minisearch@7';

    // Category definitions
    const CATEGORIES = [
      { id: 'type', label: 'Type', source: 'type' },
      { id: 'genre', label: 'Genre', source: 'facets', key: 'genre' },
      { id: 'era', label: 'Era', source: 'facets', key: 'era', altKey: 'active-era' },
      { id: 'tone', label: 'Tone', source: 'facets', key: 'tone' },
      { id: 'morality', label: 'Morality', source: 'facets', key: 'morality' },
      { id: 'archetype', label: 'Archetype', source: 'facets', key: 'archetype' },
      { id: 'role', label: 'Role', source: 'tags', values: ['spy', 'detective', 'assassin', 'thief', 'mobster', 'gangster', 'criminal', 'soldier', 'warrior', 'wizard', 'witch', 'villain', 'hero', 'butler', 'agent', 'operative', 'investigator', 'vigilante', 'mentor', 'sidekick', 'henchman', 'mastermind', 'informant', 'con-artist', 'hitman', 'double-agent', 'femme-fatale'] },
      { id: 'profession', label: 'Profession', source: 'facets', key: 'profession' },
      { id: 'reality', label: 'Reality', source: 'facets', key: 'reality' },
      { id: 'locationType', label: 'Location Type', source: 'facets', key: 'location-type' },
      { id: 'franchise', label: 'Franchise', source: 'tags', values: ['batman', 'gotham', 'dc-universe', 'dark-knight', 'james-bond', '007', 'back-to-the-future', 'hill-valley', 'the-godfather', 'corleone', 'middle-earth', 'lord-of-the-rings', 'the-hobbit', 'foundation', 'discworld', 'sherlock-holmes', 'neuromancer', 'inception', 'tenet', 'interstellar', 'the-prestige', 'oppenheimer', 'christopher-nolan'] },
    ];

    // Convert kebab-case to Title Case
    function toLabel(str) {
      if (!str) return '';
      return str.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    }

    // Modifier types
    const MODIFIER = {
      OR: 'or',     // Default: include in union
      NOT: 'not',   // Exclude these
      MUST: 'must'  // Must have (intersection)
    };

    // Modifier cycle order: or -> not -> must -> or
    const MODIFIER_CYCLE = [MODIFIER.OR, MODIFIER.NOT, MODIFIER.MUST];

    // State
    let index = null;
    let allEntities = [];
    let activeFilters = {}; // { categoryId: Map<value, modifier> }

    // DOM elements
    const searchEl = document.getElementById('search');
    const filtersEl = document.getElementById('filters');
    const resultsEl = document.getElementById('results');
    const resultsHeaderEl = document.getElementById('resultsHeader');
    const clearFiltersEl = document.getElementById('clearFilters');

    // Initialize
    async function init() {
      const res = await fetch('./build/search-index.json');
      const indexData = await res.text();
      index = MiniSearch.loadJSON(indexData, {
        fields: ['name', 'description', 'body', 'aliases', 'tags', 'facetText', 'related']
      });

      // Get all entities from index
      allEntities = [];
      index._documentIds.forEach((_, docId) => {
        const stored = index._storedFields.get(docId);
        if (stored) {
          allEntities.push({
            id: stored.id,
            type: stored.type,
            name: stored.name,
            description: stored.description,
            facets: stored.facets || {},
            tagsArray: stored.tagsArray || []
          });
        }
      });

      // Initialize empty filters (Maps to store value -> modifier)
      CATEGORIES.forEach(cat => {
        activeFilters[cat.id] = new Map();
      });

      render();
    }

    // Get values for a category from an entity
    function getEntityValuesForCategory(entity, category) {
      const values = new Set();

      if (category.source === 'type') {
        if (entity.type) values.add(entity.type);
      } else if (category.source === 'facets') {
        const facetVal = entity.facets?.[category.key];
        const altVal = category.altKey ? entity.facets?.[category.altKey] : null;

        [facetVal, altVal].forEach(val => {
          if (Array.isArray(val)) {
            val.forEach(v => values.add(v));
          } else if (val) {
            values.add(val);
          }
        });
      } else if (category.source === 'tags') {
        const tags = entity.tagsArray || [];
        tags.forEach(tag => {
          if (category.values.includes(tag)) {
            values.add(tag);
          }
        });
      }

      return values;
    }

    // Check if entity matches all active filters
    function entityMatchesFilters(entity) {
      for (const category of CATEGORIES) {
        const filters = activeFilters[category.id];
        if (filters.size === 0) continue;

        const entityValues = getEntityValuesForCategory(entity, category);

        // Group filters by modifier
        const orValues = [];
        const notValues = [];
        const mustValues = [];

        for (const [value, modifier] of filters) {
          if (modifier === MODIFIER.OR) orValues.push(value);
          else if (modifier === MODIFIER.NOT) notValues.push(value);
          else if (modifier === MODIFIER.MUST) mustValues.push(value);
        }

        // NOT: entity must not have any of these
        for (const v of notValues) {
          if (entityValues.has(v)) return false;
        }

        // MUST: entity must have ALL of these
        for (const v of mustValues) {
          if (!entityValues.has(v)) return false;
        }

        // OR: entity must have at least one (if there are OR values and no MUST values matched)
        if (orValues.length > 0 && mustValues.length === 0) {
          const hasOrMatch = orValues.some(v => entityValues.has(v));
          if (!hasOrMatch) return false;
        }
      }
      return true;
    }

    // Get current results based on search + filters
    function getResults() {
      const query = searchEl.value.trim();
      let results;

      if (query) {
        // Search with MiniSearch
        const searchResults = index.search(query, {
          prefix: true,
          fuzzy: query.length > 5 ? 0.2 : false,
          boost: { name: 10, aliases: 5, related: 3, tags: 2, description: 1, facetText: 0.5, body: 0.1 }
        });

        // Map to entities with scores
        results = searchResults.map(r => {
          const entity = allEntities.find(e => e.id === r.id);
          return entity ? { ...entity, score: r.score } : null;
        }).filter(Boolean);
      } else {
        // No search query - return all entities
        results = allEntities.map(e => ({ ...e, score: 0 }));
      }

      // Apply filters
      results = results.filter(entityMatchesFilters);

      // Sort by score (if searched) or name
      if (query) {
        results.sort((a, b) => b.score - a.score);
      } else {
        results.sort((a, b) => a.name.localeCompare(b.name));
      }

      return results;
    }

    // Check if entity matches filters for a specific category (used for available filter calculation)
    function entityMatchesCategoryFilters(entity, category) {
      const filters = activeFilters[category.id];
      if (filters.size === 0) return true;

      const entityValues = getEntityValuesForCategory(entity, category);

      const orValues = [];
      const notValues = [];
      const mustValues = [];

      for (const [value, modifier] of filters) {
        if (modifier === MODIFIER.OR) orValues.push(value);
        else if (modifier === MODIFIER.NOT) notValues.push(value);
        else if (modifier === MODIFIER.MUST) mustValues.push(value);
      }

      // NOT check
      for (const v of notValues) {
        if (entityValues.has(v)) return false;
      }

      // MUST check
      for (const v of mustValues) {
        if (!entityValues.has(v)) return false;
      }

      // OR check
      if (orValues.length > 0 && mustValues.length === 0) {
        if (!orValues.some(v => entityValues.has(v))) return false;
      }

      return true;
    }

    // Check if category has any MUST modifiers
    function categoryHasMust(categoryId) {
      for (const [, modifier] of activeFilters[categoryId]) {
        if (modifier === MODIFIER.MUST) return true;
      }
      return false;
    }

    // Get available filter options
    function getAvailableFilters() {
      const available = {};
      const query = searchEl.value.trim();

      // Get search results if there's a query
      let searchMatchIds = null;
      if (query) {
        const searchResults = index.search(query, {
          prefix: true,
          fuzzy: query.length > 5 ? 0.2 : false
        });
        searchMatchIds = new Set(searchResults.map(r => r.id));
      }

      for (const category of CATEGORIES) {
        const valuesWithResults = new Set();
        const hasMustInCategory = categoryHasMust(category.id);

        for (const entity of allEntities) {
          // Check if entity matches search (if any)
          if (searchMatchIds && !searchMatchIds.has(entity.id)) continue;

          // Check if entity matches all OTHER categories' filters
          let matchesOtherFilters = true;
          for (const otherCat of CATEGORIES) {
            if (otherCat.id === category.id) continue;
            if (!entityMatchesCategoryFilters(entity, otherCat)) {
              matchesOtherFilters = false;
              break;
            }
          }

          if (!matchesOtherFilters) continue;

          // For MUST mode: also check if entity matches current category's MUST/NOT filters
          // This narrows down options to only compatible values
          if (hasMustInCategory) {
            if (!entityMatchesCategoryFilters(entity, category)) continue;
          }

          // This entity would be in results if we selected any of its values for this category
          const values = getEntityValuesForCategory(entity, category);
          values.forEach(v => valuesWithResults.add(v));
        }

        // Always include currently selected values (so user can deselect/modify them)
        for (const [v] of activeFilters[category.id]) {
          valuesWithResults.add(v);
        }

        if (valuesWithResults.size > 0) {
          // Sort alphabetically
          const sorted = [...valuesWithResults].sort((a, b) => a.localeCompare(b));

          available[category.id] = {
            label: category.label,
            values: sorted.map(v => [v])
          };
        }
      }

      return available;
    }

    // Render filters
    function renderFilters(available) {
      filtersEl.innerHTML = '';

      // Check if any filters are active
      const hasActiveFilters = CATEGORIES.some(cat => activeFilters[cat.id].size > 0);
      clearFiltersEl.classList.toggle('visible', hasActiveFilters);

      for (const category of CATEGORIES) {
        const options = available[category.id];
        if (!options) continue; // Hide category if no options

        const categoryEl = document.createElement('div');
        categoryEl.className = 'category';

        const titleEl = document.createElement('div');
        titleEl.className = 'category-title';
        titleEl.textContent = options.label;
        categoryEl.appendChild(titleEl);

        const optionsEl = document.createElement('div');
        optionsEl.className = 'category-options';

        for (const [value] of options.values) {
          const optionEl = document.createElement('div');
          optionEl.className = 'filter-option';

          const currentModifier = activeFilters[category.id].get(value);
          const isSelected = currentModifier !== undefined;

          if (isSelected) {
            optionEl.classList.add('selected');
            if (currentModifier === MODIFIER.NOT) {
              optionEl.classList.remove('selected');
              optionEl.classList.add('modifier-not');
            } else if (currentModifier === MODIFIER.MUST) {
              optionEl.classList.remove('selected');
              optionEl.classList.add('modifier-must');
            }
          }

          // Build label with modifier prefix
          let label = toLabel(value);
          if (currentModifier === MODIFIER.NOT) {
            label = '! ' + label;
          } else if (currentModifier === MODIFIER.MUST) {
            label = '+ ' + label;
          }
          optionEl.textContent = label;

          // Click handler
          optionEl.addEventListener('click', (e) => {
            e.preventDefault();
            const useModifier = e.altKey || e.metaKey; // Option or Cmd key
            if (useModifier) {
              // Option+click: cycle modifier
              if (!isSelected) {
                // Not selected yet, add with OR
                activeFilters[category.id].set(value, MODIFIER.OR);
              } else {
                // Cycle: or -> not -> must -> or
                const currentIndex = MODIFIER_CYCLE.indexOf(currentModifier);
                const nextIndex = (currentIndex + 1) % MODIFIER_CYCLE.length;
                activeFilters[category.id].set(value, MODIFIER_CYCLE[nextIndex]);
              }
            } else {
              // Regular click: toggle selection
              if (isSelected) {
                activeFilters[category.id].delete(value);
              } else {
                activeFilters[category.id].set(value, MODIFIER.OR);
              }
            }
            render();
          });

          optionsEl.appendChild(optionEl);
        }

        categoryEl.appendChild(optionsEl);
        filtersEl.appendChild(categoryEl);
      }
    }

    // Render results
    function renderResults(results) {
      const query = searchEl.value.trim();

      resultsHeaderEl.textContent = `${results.length} result${results.length !== 1 ? 's' : ''}`;

      if (results.length === 0) {
        resultsEl.innerHTML = '<div class="empty-state">No results found</div>';
        return;
      }

      resultsEl.innerHTML = results.slice(0, 50).map(entity => {
        // Collect display tags (facet values + tags)
        const displayTags = [];
        if (entity.facets) {
          ['genre', 'morality', 'archetype', 'era', 'tone', 'profession', 'reality'].forEach(key => {
            const val = entity.facets[key];
            if (Array.isArray(val)) {
              val.forEach(v => displayTags.push(toLabel(v)));
            } else if (val) {
              displayTags.push(toLabel(val));
            }
          });
        }

        const tagsHtml = displayTags.slice(0, 5).map(t =>
          `<span class="result-tag">${t}</span>`
        ).join('');

        return `
          <div class="result">
            <div class="result-header">
              <span class="result-name">${entity.name}</span>
              <span class="result-type">${entity.type}</span>
            </div>
            <div class="result-description">${entity.description || ''}</div>
            ${tagsHtml ? `<div class="result-meta">${tagsHtml}</div>` : ''}
          </div>
        `;
      }).join('');
    }

    // Main render function
    function render() {
      const results = getResults();
      const available = getAvailableFilters();

      renderFilters(available);
      renderResults(results);
    }

    // Event listeners
    searchEl.addEventListener('input', () => render());

    clearFiltersEl.addEventListener('click', () => {
      CATEGORIES.forEach(cat => {
        activeFilters[cat.id] = new Map();
      });
      render();
    });

    // Start
    init();
  </script>
</body>
</html>
